# 25EDC - 17年E题 - 自适应滤波代码实战

- [赛题回顾](https://blog.csdn.net/weixin_41198651/article/details/105848937)

> 粗糙的摆盘

![成果展示](https://cdn.jsdelivr.net/gh/dixiLOG/blogStatic/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250723221040.jpg)

## 关键特性

- LMS 自适应滤波器
- 纯软件处理
- 50Hz频差，5%幅值误差（检测，非输出）

通过两个ADC+DMA采集两路信号，LMS配置合适阶数与学习率，加上反双线性幅值补偿，实现50Hz频差下的信号恢复，频率误差在1%以内，幅度误差，干扰信号为正弦波/三角波下最差为5%，方波下为10%左右

## 写在前面

这是一份关于2025电子设计竞赛E题的自适应滤波代码实战，从`main`分支的general版本出发修剪而成，算是一次完整的实战经历，特此记录（记性不好🤣）

具体代码已经整理注释，此处不再拘泥于细节（纯懒）

Anyway，下面将从`思路复盘`，`配置修改`与`实现原理`三个方面逐层介绍25EDC的自适应滤波器的实现过程。

> 前后一个星期的996，能搞点有意思的东西，姑且算是不负时光吧~

## 思路复盘

让我们着眼于自适应滤波器模块的设计，前面的信号加法与相移不再多赘述

乍一看，基于`移相+减法+RMS-DC反馈`的硬软结合方案是最合适的。MCU通过采集输入的DC信号，梯度下降找出最终的相位，并控制B信号移相对齐再相减，最终输出干净的目标信号

但经过深思熟虑 ~~实则不然~~ ，我们认为电路设计过于Complicated，而且这一设计的前提是B参考信号必须和混合信号中的完全一致，否则NO WAY

问了问神通广大的Gemini老师，人老人家一语中的：利用LMS自适应滤波器，可以实现信号的自适应滤波，即根据输入信号的特性，自动调整滤波器的阶数和学习率，从而达到信号的平滑、稳定、自适应的效果，没毛病

于是我们一拍即合，噩梦也由此开始😭

### 关于LMS滤波器

百度一下，你就知道：

- [自适应滤波器——知乎](https://zhuanlan.zhihu.com/p/349131657)
- [自适应滤波器减噪—Jacky's blogs](https://wangjs-jacky.github.io/2020/03/24/%E8%87%AA%E9%80%82%E5%BA%94%E6%BB%A4%E6%B3%A2%E5%99%A8%E5%87%8F%E5%99%AA/#%E8%87%AA%E9%80%82%E5%BA%94%E6%BB%A4%E6%B3%A2%E5%99%A8%E5%87%8F%E5%99%AA)
- [自适应滤波中期望信号的理解（不含推导过程）—博客园](https://www.cnblogs.com/LFYMay23/p/12582132.html)

一句话去理解，即： **滤波器会提取出输入信号和参考信号中相关性大的那部分，并且让它逼近参考信号中的那部分**

## 配置修改
 
按照预设的方案，应有两路ADC分别采集混合信号和参考信号，在LMS处理后输出无失真的目标信号

于是有以下修改（基于25EDC的配置）：

**外设上**：

- ADC3修改为单通道采集，开DMA中断，同TIM2控制
- 添加`DAC7612.c`，用于程控放大（AD9833不能控制幅度）
- 其余用到的外设有：LCD

**计算上用到的函数**：

- `fft.c`：虽然叫FFT，但信号处理函数都写这里了（懒蛋是这样的¯\\_(ツ)_/¯）
    - `DSP_FFT(float32_t *FFT_Data, float32_t *fft_buffer)`：最普通的FFT，只求LMS输出信号最大峰对应的频率
    - `find_max_value_500(float32_t* data)`：通过 **观察** 得到的取LMS输出信号幅值的函数
    - `estimate_theoretical_amp(float f_query_kHz, float V_meas)`：幅值补偿，二维线性反差值
    - `Amp2Num(float amp_query)`:程控放大控制参数的线性映射

- `arm_cmsis_dsp.c`：计算库
    - `DSP_LMS_FILTER`:核心函数，基于输入信号和参考信号，通过妙妙作差，得到输出信号
    - `DSP_SCALE`：比例缩放，用于LMS输出信号幅值调整（因为ADC采样进来的信号幅值并不是一开始的设定值，所以需要缩放）
    - `DSP_MEAN`： 取均值

> 到这里你应该可以直接通过main.c函数理解我的思路。下面是我的碎碎念和踩雷经历，除了对我，没甚卵用

## 实现原理

把上述的方案细化，我们需要：

- ADC采样最高100KHz的方波，幅值0.5V~1V，即混合信号最高2V的幅值
- 至少100Hz的分辨率
- 对LMS之后的输出波形分别进行FFT和幅值计算，误差不得超过10%
- AD9833与程控放大（这里采用AD603）稳定输出

其中最后一点暂不考虑。那么目前需要考虑的问题是（当然当时肯定没考虑这么多）：

- ADC采样频率与FFT点数
- SRAM的192KB空间是否足够？是否会爆栈？
- 如何控制LMS的阶数与学习率？
- 如何补偿幅值？

OK，下面就是具体的踩雷过程

首先，为了尽可能提高分辨率，我把采样率设置为256KHz，点数仍然为4096点，如此能得到62.5Hz的分辨率

原则上这仍然是不满足的，但我们并不奢求于直接通过傅里叶变换得到所有（在尝试了一天的Zoom-FFT和CZT后宣告失败，频谱细化并不意味着超分辨率）。对于LMS来说，所输出的波形频率只与目标波形有关，而与频差无关，所以最后一定能收敛至目标频率附近

而鉴于题目10%的误差，在99.9KHz与100KHz的波形中，FFT随便计算出哪一个都是OK的

但内存的问题又随之而来（是个插曲）。已知float32_t占4B，所以FFT的输出需要4096*4B=16KB，而SRAM只有192KB，这就很难满足要求，加上LMS上的5个float32_t参数，有些捉襟见肘

反复试探后，我选择声明`union`关键字，使得FFT与LMS的参数复用一个物理地址，这才结束了这个危机

具体来说，长这样

```c 
typedef struct {
    union {
        struct {
            float32_t lms_refInput[TEST_LENGTH_SAMPLES];
            float32_t lms_testInput[TEST_LENGTH_SAMPLES];
            float32_t lms_lmsOutput[TEST_LENGTH_SAMPLES];
        };
        float32_t fft_buffer[TEST_LENGTH_SAMPLES * 2];
    };
    
    float32_t error_buf[TEST_LENGTH_SAMPLES];
    float32_t fir_coeffs[NUM_TAPS];
    float32_t lms_state[NUM_TAPS + TEST_LENGTH_SAMPLES - 1];
} dsp_workspace_t;

dsp_workspace_t dsp_workspace;

arm_lms_instance_f32 S;
```

> 接下来的问题才是一个bug修一天

首先，是我理解错了LMS用于噪声抵消的传参。实际上，输入脚应该是所谓的`参考信号B`，参考信号脚（期望信号）是混合信号（具体为什么看我给的参考，与LMS的原理有关）

我一开始搞混了，导致LMS的输出信号是B，相当于一线通。因此输出结果非常惊艳，我非常乐观的认为游戏已经结束了（只是一个 **输出信号反了的小问题** ），但事实并非如此

在终于看见并修正后，波形有点对了，但还是不对。无论我输入什么频率，最后总是会收敛到0

一顿小鸡炖蘑菇后，意识到问题出在直流分量上

LMS的输出是双极性的，而输入的信号带有偏置。直流分量的超级无敌相关性使得最终LMS收敛与直流，即0

于是我哼哧哼哧在`DSP_LMS_FILTER`里面加了去直流，非常乐观的认为游戏已经结束了，但事实并非如此

在削去直流后，波形有点对了，但还是哪里不对。每次我uart输出plot波形时，惊奇地发现LMS并没有在收敛，而是周期性的重复

心思敏锐的我花了俩天的时间就意识到，LMS函数的初始化设置不对，每一次调用都刷新了结构体，破坏了原有的特征

于是我哼哧哼哧把`DSP_LMS_FILTER`改了，把初始化放到main函数里面，结构体也改为全局，输出波形终于有点感觉了

后面就开始枯燥的调参和观察，主要是希望能找到一个Tap和mu，使得频差较小时（相关性大）的输出波形的幅值衰减有所规律

在F4中调试太繁琐了，幸得刚子指点，改用Matlab仿真，于是搓了个GUI出来点来点去

![matlab仿真](https://cdn.jsdelivr.net/gh/dixiLOG/blogStatic/PixPin_2025-07-23_23-22-47.jpg)

对于幅值的观察，我取了80个包络点，通过扫频观察其均值与频差之间的关系，发现1.2KHz内呈现惊人的线性（同时也会受干扰信号的幅值影响）

这给了我一些信心，又是一顿小鸡炖蘑菇，我似乎找到了一个Aha parameter，再在F4上试一试（说得好轻松），成功地让幅值有迹可循

具体来说：

- 固定有用信号的幅值，那么所需补偿的差值与信号的频率线性相关
- 固定信号的频率，那么所需补偿的幅值与信号的幅值线性相关

想到了什么？双线性差值！

于是我哼哧哼哧记录了几十个点，即一个二维数组，那么通过这个数组与目标信号的频率与“测量幅值”，就可以得到所需补偿的幅值（双线性反插值）

所以我们在LMS之后，先计算频率，再计算幅值，再在去均值后进行补偿

结果非常Amazing啊，令我老泪纵横，难道一个星期前所说一个单片机搞定一个模块的论断就要实现了吗？

啊并没有，最后一步的输出还是被卡了一天

因为AD603是dB线性而非比例线性，所以担忧误差会有些大，但思考了好几个版本，还是回到了最 ~ 初 ~ 的 ~ 起 ~ 点 ~，精度差点就差点吧（AD9959+固定比例放大，或者乘法器应该是更优解）

画图什么的就不多说了，整个项目到底算是结束了🫡

> 学到的最大的教训：要么全信Gemini，要么不信Gemini，信一半自己又不懂必出问题

## 许可证

本项目采用MIT许可证，详见 [LICENSE](LICENSE) 文件。

---

- **开发者**: dixi
- **项目**: 25EDC - 2025电子设计竞赛
